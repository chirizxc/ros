# ResNet

## 1. Объясните, как остаточные соединения (skip-connections) в ResNet решают проблему затухания градиента. Приведите формулу и поясните её смысл.
Остаточные соединения позволяют градиенту напрямую проходить через слои, минуя некоторые нелинейности. Это решает проблему затухания градиента в глубоких сетях.

**Формула:**  
y = F(x) + x  
где F(x) — это выход из сверточных слоев (остаточная функция), а x — вход.  
**Смысл:** если F(x) → 0, то y ≈ x, что помогает сохранить информацию и стабильность градиентов.

## 2. Почему в ResNet-50 используются Bottleneck-слои (1×1 → 3×3 → 1×1)? Какие задачи они решают в архитектуре?
Bottleneck-слои уменьшают количество параметров и вычислений, сохраняя глубину сети.  
- Первый 1×1 слой снижает размерность признаков.  
- 3×3 — извлекает пространственные признаки.  
- Последний 1×1 восстанавливает размерность.  
Это делает сеть глубокой и быстрой одновременно.

## 3. Чем отличается предобработка изображений для ResNet-50 от исходного размера изображений в CIFAR-10? Почему это важно?
- **CIFAR-10**: изображения 32×32, нормализация простая.  
- **ResNet-50 (ImageNet)**: ожидает 224×224 изображения и нормализацию с конкретными средними и std.  
**Важно:** ResNet-50 требует изменения размера и нормализации под ImageNet-формат.

## 4. Какие проблемы возникают при использовании модели, обученной на ImageNet (1000 классов), для классификации CIFAR-10 (10 классов)? Как в работе решалась эта проблема?
ResNet-50 обучена на 1000 классов ImageNet.  
**Проблемы:**
- Несоответствие классов.
- Перенос признаков может быть неточным.  
**Решение:** создать отображение классов и адаптировать выходы модели.

## 5. Как функция map_imagenet_to_cifar10 агрегирует классы ImageNet? Приведите примеры ключевых слов для двух классов CIFAR-10.
Функция сопоставляет группы классов ImageNet с 10 классами CIFAR-10.

**Примеры ключевых слов:**
- **"airplane"**: включает "airliner", "warplane", "jet".  
- **"dog"**: включает "Labrador", "Beagle", "Chihuahua".

## 6. Зачем в коде применяется денормализация изображений перед их визуализацией? Какие параметры нормализации использовались и почему?
Нормализованные изображения выглядят неестественно (сжатые значения).  
**Нормализация ImageNet:**
- Среднее: `[0.485, 0.456, 0.406]`
- Стд: `[0.229, 0.224, 0.225]`  
**Денормализация** возвращает изображения к исходному виду для визуализации.

## 7. Какие метрики используются для оценки качества модели в работе? Объясните, что показывает F1-score и в чём его преимущество перед accuracy.
- Accuracy
- Precision / Recall
- F1-score

**F1-score** — гармоническое среднее Precision и Recall.  
**Преимущество:** сбалансированная оценка при несбалансированных данных.

## 8. Почему при оценке модели на CIFAR-10 с помощью ResNet-50 могут возникать ошибки, связанные с различиями в доменах данных (ImageNet vs CIFAR-10)?
ImageNet и CIFAR-10 сильно отличаются по содержанию, разрешению, контексту.  
Это вызывает:
- Ошибки в распознавании.
- Переобучение на нерелевантные признаки.

## 9. Как матрица ошибок (confusion matrix) помогает анализировать слабые места модели? Приведите пример интерпретации.
Показывает, какие классы путает модель.

**Пример:** модель часто путает "cat" и "dog" → нужно улучшить признаки для этих классов.

## 10. Что произойдёт, если в функции imagenet_to_cifar10_prediction не учесть классы ImageNet, не соответствующие ни одному классу CIFAR-10? Как это повлияет на итоговые предсказания?
Такие классы могут быть случайно выбраны как предсказание.  
**Следствие:** снижение точности, некорректные метки.  
**Решение:** игнорировать или переназначить такие классы.

---
# ResNeXt

## 11. Объясните, что такое cardinality в архитектуре ResNeXt. Как увеличение этого параметра влияет на производительность модели и её вычислительную сложность?

**Cardinality** — это число параллельных путей (групп) в сверточном блоке ResNeXt.  
**Увеличение cardinality** позволяет модели захватывать больше разнообразных признаков, повышая точность без значительного роста вычислительной сложности. Однако слишком большое значение может увеличить требования к памяти и времени обучения.

## 12. В чём ключевое отличие ResNeXt от классической ResNet? Почему ее операции считаются более эффективными, чем стандартные?

**ResNeXt** использует групповые свёртки (grouped convolutions), что позволяет обрабатывать данные параллельно в нескольких путях (cardinality).  
**Эффективность** достигается за счёт увеличения разнообразия признаков при том же числе параметров, что и у ResNet, но с меньшей вычислительной нагрузкой.

## 13. Опишите три основных подхода к fine-tuning предобученных моделей. В каких ситуациях рекомендуется использовать частичное fine-tuning вместо полного?

1. **Feature extraction** — замораживаются все слои, кроме последнего, обучается только классификатор.
2. **Partial fine-tuning** — размораживаются верхние слои, остальные остаются фиксированными.
3. **Full fine-tuning** — обучаются все слои модели.

**Частичный fine-tuning** рекомендуется, если новый датасет похож на исходный, чтобы избежать переобучения и ускорить обучение.

## 14. Почему для задач многоклассовой классификации, таких как CIFAR-100, используется функция потерь CrossEntropyLoss? Как она связана с логитами и вероятностями классов?

**CrossEntropyLoss** сравнивает логиты модели с истинными метками, автоматически применяя softmax для получения вероятностей классов. Она измеряет, насколько предсказанные вероятности близки к истинным меткам, что важно для многоклассовых задач.

## 15. Какие преимущества даёт использование оптимизатора SGD с параметром momentum? Как момент помогает ускорить сходимость обучения?

**Momentum** помогает ускорить обучение, накапливая прошлые градиенты и сглаживая обновления весов. Это позволяет быстрее проходить плоские участки и избегать локальных минимумов, ускоряя сходимость.

## 16. Почему при адаптации предобученной модели к новым данным часто используют меньший learning rate, чем при обучении с нуля? Какие риски возникают при слишком высоком learning rate?

**Меньший learning rate** нужен, чтобы не разрушить уже выученные полезные признаки.  
**Слишком высокий learning rate** может привести к потере знаний, неустойчивому обучению и ухудшению качества модели.

## 17. Для чего применяется нормализация изображений перед подачей в модель? Какие значения среднего и стандартного отклонения обычно используются для датасета ImageNet и почему?

**Нормализация** приводит входные данные к единому масштабу, ускоряя и стабилизируя обучение.  
Для ImageNet обычно используют:  
- среднее: `[0.485, 0.456, 0.406]`
- стандартное отклонение: `[0.229, 0.224, 0.225]`  
Эти значения соответствуют статистике всего датасета.

## 18. Какие метрики включает classification_report и как они интерпретируются? Почему важно анализировать не только точность (accuracy), но и precision/recall?

Включает:  
- **precision** (точность) — доля верно предсказанных положительных,
- **recall** (полнота) — доля найденных всех истинных положительных,
- **f1-score** — гармоническое среднее precision и recall,
- **support** — число истинных примеров каждого класса.

**Важно** анализировать precision/recall, чтобы понять баланс между ложными срабатываниями и пропущенными случаями, особенно при несбалансированных классах.

## 19. Что показывает матрица ошибок (confusion matrix)? Как её анализ помогает выявить слабые места модели?

**Матрица ошибок** показывает, сколько объектов каждого класса были правильно или ошибочно классифицированы.  
Анализ помогает выявить, какие классы чаще всего путаются, и направить усилия на улучшение этих мест.

## 20. Чем отличается режим обучения от режима инференса в PyTorch? Почему важно переключать режимы при обучении и тестировании?

В режиме **обучения** (`model.train()`) активны dropout и batch normalization с обновлением статистики.  
В режиме **инференса** (`model.eval()`) отключается dropout и используются зафиксированные параметры batch norm.  
**Важно** переключать режимы, чтобы получить корректные результаты и избежать ошибок в предсказаниях.

---
# Faster R-CNN

## 21. Чем отличаются одностадийные и двухстадийные модели детекции объектов? Какие преимущества и недостатки есть у каждого подхода?

**Одностадийные модели** (например, YOLO, SSD) сразу предсказывают классы и координаты объектов за один проход по изображению.  
- **Преимущества:** высокая скорость, подходят для real-time задач.  
- **Недостатки:** ниже точность на мелких и плотно расположенных объектах.

**Двухстадийные модели** (например, Faster R-CNN) сначала выделяют области-кандидаты (region proposals), затем классифицируют и уточняют их границы.  
- **Преимущества:** высокая точность, особенно для сложных сцен.  
- **Недостатки:** медленнее, требуют больше вычислений[[1]].

## 22. Назовите основные компоненты архитектуры Faster R-CNN и опишите роль каждого из них.

1. **Backbone (CNN):** извлекает признаки из изображения.
2. **Region Proposal Network (RPN):** генерирует области-кандидаты (region proposals).
3. **ROI Pooling:** преобразует области-кандидаты к фиксированному размеру.
4. **Классификатор и регрессор:** определяют класс объекта и уточняют координаты рамки[[1]].

## 23. Какую функцию выполняет Region Proposal Network (RPN) в Faster R-CNN?

**RPN** автоматически генерирует области-кандидаты (region proposals) на основе карты признаков, что ускоряет и упрощает процесс по сравнению с внешними алгоритмами поиска областей[[1]].

## 24. Опишите структуру аннотаций в формате Pascal VOC. Какая информация содержится в XML-файлах?

XML-файл Pascal VOC содержит:
- Имя изображения и его размер,
- Для каждого объекта: имя класса, координаты ограничительной рамки (xmin, ymin, xmax, ymax),
- Доп. параметры: трудность (difficult), наличие объекта (truncated, occluded).

## 25. Что такое метрика IoU (Intersection over Union)? Как она используется для оценки качества детекции объектов?

**IoU** — отношение площади пересечения предсказанной и истинной рамки к площади их объединения.  
Используется для определения, насколько хорошо предсказанная рамка совпадает с реальной: если IoU выше порога (например, 0.5), детекция считается успешной.

## 26. Как параметр Confidence Score влияет на фильтрацию предсказаний модели? Какие проблемы могут возникнуть при выборе слишком высокого или низкого порога?

**Confidence Score** — вероятность наличия объекта в рамке.  
- **Слишком высокий порог:** пропуск объектов (больше FN).
- **Слишком низкий порог:** много ложных срабатываний (больше FP).

## 27. Каким образом подсчитываются False Positives (FP) и False Negatives (FN) в задачах детекции? Как IoU связан с этими метриками?

- **FP:** предсказанная рамка не соответствует ни одному реальному объекту (IoU ниже порога).
- **FN:** реальный объект не был обнаружен (нет предсказанной рамки с IoU выше порога).
- **IoU** определяет, считать ли предсказание успешным или ошибочным.

## 28. Для чего используется Non-Maximum Suppression (NMS) в Faster R-CNN? Опишите алгоритм его работы.

**NMS** удаляет дублирующие рамки для одного объекта:
1. Сортирует рамки по confidence score.
2. Выбирает рамку с наибольшим score, удаляет все перекрывающиеся с ней (IoU выше порога).
3. Повторяет для оставшихся рамок.

## 29. Как выбор backbone-сети (ResNet, VGG, MobileNet) влияет на производительность и скорость Faster R-CNN?

- **ResNet:** баланс между точностью и скоростью, хорошо подходит для сложных задач.
- **VGG:** высокая точность, но медленная и ресурсоёмкая.
- **MobileNet:** высокая скорость и низкое потребление ресурсов, но ниже точность.
Выбор зависит от требований к скорости и точности.

---
# Mask R-CNN

## 30. Какие шаги необходимо выполнить для применения предобученной модели Faster R-CNN к новому изображению? Опишите этапы предобработки данных и инференса.

1. **Предобработка:** изменение размера, нормализация изображения.
2. **Подача в модель:** получение предсказаний (bounding boxes, классы, confidence scores).
3. **Фильтрация:** удаление слабых предсказаний по порогу confidence.
4. **NMS:** устранение дубликатов.
5. **Визуализация:** отображение рамок и классов на изображении.

## 31. Объясните разницу между instance segmentation и semantic segmentation. Приведите примеры задач, где каждый из подходов наиболее применим.

**Semantic segmentation** — каждому пикселю изображения присваивается класс, но объекты одного класса не различаются между собой (например, все машины на дороге — просто "машины")[[1]][[2]][[3]][[4]].  
**Instance segmentation** — каждому объекту (экземпляру) присваивается уникальная маска, даже если объекты одного класса перекрываются (например, каждая машина на дороге выделяется отдельно)[[1]][[2]][[3]][[4]].

**Примеры применения:**  
- Semantic segmentation: разметка дорог, неба, зданий на спутниковых снимках.  
- Instance segmentation: подсчёт людей на фото, выделение отдельных клеток на микроснимках.

## 32. Опишите назначение и взаимодействие компонентов Mask R-CNN: Backbone, Region Proposal Network (RPN), ROI Align, Bounding Box Head, Mask Head. Почему ROI Align считается улучшением по сравнению с ROI Pooling?

- **Backbone** — извлекает признаки из изображения (например, ResNet)[[1]][[3]][[5]].
- **RPN** — генерирует регионы-кандидаты, где могут находиться объекты[[1]][[3]][[5]].
- **ROI Align** — точно вырезает признаки для каждого региона без округления координат, что повышает точность масок[[5]].
- **Bounding Box Head** — уточняет координаты рамки и определяет класс объекта[[1]][[3]][[5]].
- **Mask Head** — предсказывает бинарную маску для каждого объекта[[1]][[3]][[5]].

**ROI Align** лучше, чем ROI Pooling, потому что не округляет координаты и использует билинейную интерполяцию, что важно для точной пиксельной сегментации[[5]].

## 33. На каких принципах основано вычисление метрики Intersection over Union (IoU) для масок? Какие ограничения есть у этой метрики, и какие альтернативные метрики можно использовать?

**IoU для масок** — отношение площади пересечения предсказанной и истинной маски к площади их объединения.  
**Ограничения:** не учитывает степень совпадения формы, чувствителен к небольшим смещениям, плохо работает для сильно перекрывающихся объектов.  
**Альтернативы:** Dice coefficient, Average Precision (AP) по IoU, Boundary IoU.

## 34. Какие ключевые различия существуют между форматами аннотаций в Pascal VOC, COCO и Cityscapes? Как эти различия влияют на процесс обучения и оценки моделей сегментации?

- **Pascal VOC:** XML-файлы, bounding boxes, классы, иногда маски (простые формы).
- **COCO:** JSON, поддержка сложных полигональных масок, несколько аннотаций на объект, больше информации о сегментации.
- **Cityscapes:** ориентирован на городской ландшафт, pixel-level маски, отдельные классы для instance и semantic segmentation.

**Влияние:**  
COCO и Cityscapes позволяют обучать и оценивать модели на более сложных и разнообразных масках, что важно для instance segmentation. Pascal VOC проще, но менее гибок для сложных задач.

## 35. Как Region Proposal Network генерирует регионы-кандидаты для последующей обработки? Какие критерии используются для фильтрации предложенных регионов?

RPN скользит по карте признаков и для каждой позиции генерирует несколько anchor boxes разных размеров и пропорций. Для каждого anchor вычисляется вероятность наличия объекта и регрессируются координаты.  
**Фильтрация:** по порогу уверенности (objectness score), по IoU с ground truth, удаление дубликатов через Non-Maximum Suppression.

## 36. Почему маски в Mask R-CNN предсказываются для каждого класса отдельно, даже если объекты относятся к одному классу? Как это связано с задачей instance segmentation?

Для каждого объекта сеть предсказывает маску для каждого класса, но учитывается только маска, соответствующая предсказанному классу объекта. Это позволяет разделять экземпляры одного класса и решать задачу instance segmentation, где важно различать отдельные объекты, а не просто классы[[5]].

## 37. Какие теоретические принципы лежат в основе выбора параметров confidence_threshold и mask_threshold? Как эти параметры влияют на соотношение точности и полноты предсказаний?

- **confidence_threshold** — минимальная уверенность для принятия предсказания (чем выше, тем меньше FP, но больше FN).
- **mask_threshold** — порог для бинаризации маски (чем выше, тем маска "чище", но можно потерять часть объекта).

**Баланс:**  
Высокие пороги увеличивают точность (precision), но снижают полноту (recall); низкие — наоборот. Оптимальные значения подбираются по валидации.

## 38. Какие типы ошибок характерны для instance segmentation? Как их можно классифицировать и минимизировать на уровне архитектуры модели?

**Типы ошибок:**  
- Пропущенные объекты (FN)
- Ложные объекты (FP)
- Неправильные маски (shape mismatch)
- Ошибки слияния/разделения экземпляров

**Минимизация:**  
- Улучшение качества RPN и маски (например, через более точный ROI Align)
- Использование дополнительных потерь (boundary loss)
- Аугментации и балансировка классов

## 39. В чём заключается ключевое отличие Mask R-CNN от Faster R-CNN? Какие модификации были внесены в архитектуру для решения задачи сегментации на уровне пикселей?

**Mask R-CNN** добавляет к Faster R-CNN отдельную ветвь для предсказания маски объекта (Mask Head) и заменяет ROI Pooling на ROI Align для точной работы с пикселями[[1]][[3]][[5]]. Это позволяет не только находить объекты и их рамки, но и сегментировать их на уровне пикселей.

## 40. Какие теоретические ограничения имеет Mask R-CNN при работе с объектами сложной формы или перекрывающимися объектами? Предложите возможные улучшения архитектуры для таких сценариев.

**Ограничения:**  
- Маски фиксированного размера могут плохо аппроксимировать сложные формы.
- Перекрывающиеся объекты могут сливаться, если RPN не выделяет отдельные регионы.
- Трудности с очень мелкими или вытянутыми объектами.

**Возможные улучшения:**  
- Использование более высоких разрешений масок.
- Добавление attention-механизмов.
- Постпроцессинг для разделения перекрывающихся масок (например, watershed, contour refinement).
- Использование специализированных архитектур (например, PointRend, SOLO).